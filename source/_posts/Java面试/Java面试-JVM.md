---
title: Java面试-JVM
date: 2023-12-29 13:21:28
categories: [JAVA]
tags: [Java面试]
---


`java`文件编译成二进制字节码`class`文件, `class`文件再通过类加载器加载到`JVM`的永久代（`jdk8`以后就变成了`Metaspace`元数据，这里说一下，永久代跟元数据都是实现方法区的手段，方法区是一种规范）. 应用启动时，通过方法区中类的元信息，静态变量，静态方法（想当于制造对象的说明书）创建对象。

1. `Java`源代码文件(`.java`后缀)会被`Java`编译器编译为字节码文件(`.class`后缀)，
2. `JVM`中的类加载器加载各个类的字节码文件。
3. 加载完毕之后，交由`JVM`执行引擎执行。
    * 在整个程序执行过程中，`JVM`会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为`Runtime Data Area`（运行时数据区），也就是我们常说的`JVM`内存。因此，在`Java`中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

# 类加载器
`Java` 的类加载过程可以分为 5 个阶段：**载入、验证、准备、解析和初始化**。

1. `Loading`（载入）: JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 `java.lang.Class` 对象。
2. `Verification`（验证）: JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。下面是一些主要的检查。
    * 确保二进制字节流格式符合预期（比如说是否以 `cafe bene` 开头）。
    * 是否所有方法都遵守访问控制关键字的限定。
    * 方法调用的参数个数和类型是否正确。
    * 确保变量在使用之前被正确初始化了。
    * 检查变量是否被赋予恰当类型的值。
3. `Preparation`（准备）: JVM 会在该阶段对**类变量**（也称为静态变量，`static` 关键字修饰的）**分配内存并初始化**（对应数据类型的默认初始值，如 0、0L、null、false 等）。
4. `Resolution`（解析）: 该阶段**将常量池中的符号引用转化为直接引用**。在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 com.Wanger 类引用了 com.Chenmo 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 com.Chenmo。
5. `Initialization`（初始化）: 是执行类构造器`<clinit>()`方法。这个方法是由编译器自动收集类中的所有**类变量的赋值动作和静态语句块**（`static {}`块）中的语句合并产生的。`clinit`是一个由编译器自动生成的类构造器方法，用于**初始化类变量和静态语句块**。

Java 类加载器:
1. 启动类加载器（Bootstrap Class-Loader）: 用来加载java核心类库。主要负责加载`JAVA_HOME/lib`下的类库。启动类加载器无法被应用程序直接使用。
2. 扩展类加载器（Extension or Ext Class-Loader）: 用来加载Java的扩展库。。加载 `jre/lib/ext` 包下面的 `jar` 文件。
3. 应用类加载器（Application or App Clas-Loader）: 它根据Java应用的类路径（`classpath`）来加载Java类。一般来说，Java应用的类都是由它来完成加载的。
4. 用户自定义类加载器: 通过继承 `java.lang.ClassLoader` 类的方式实现。

类初始化顺序(属性和代码块级别相同，按前后顺序执行):
1. 父类静态属性
2. 父类静态代码块
3. 子类静态属性
4. 子类静态代码块
5. 父类普通属性
6. 父类普通代码块
7. 父类构造方法
8. 子类普通属性
9. 子类普通代码块
10. 子类构造方法

静态内部类和非静态内部类一样，都不会因为外部类的加载而加载，同时静态内部类的加载不需要依附外部类，在使用时才加载，不过在加载静态内部类的过程中也会加载外部类

## 双亲委派机制
双亲委派机制的执行过程：
如果一个类加载器收到了类加载的请求，这个类加载器不会先尝试加载这个类，而是会先把这个请求委派给自己的父类加载器去完成，在每个层次的类加载器都是依此类推的。因此所有的类加载器请求其最后都应该被委派到顶层的启动类加载器中(Bootstrap)，只有当父类的加载器在自己管辖范围内没有找到所需要的类的时候，子类加载器才会尝试自己去加载的，如果自己管理范围内也找不到需要加载的就会抛出：`ClassNotFoundException` 这个异常了。

双亲委派的作用:
1. 防止加载同一个`.class`。通过委托去询问上级是否已经加载过该`.class`，如果加载过了，则不需要重新加载。保证了数据安全。
2. 保证核心`.class`不被篡改。通过委托的方式，保证核心`.class`不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个`class`对象，因为不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样则保证了`Class`的执行安全。
    * 如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现。
    * 双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。

# jvm 内存（堆、栈、方法区）
* 程序计数器:可以看作是当前线程所执行的字节码的行号指示器。线程私有
* 堆区:堆内存用于存放由`new`创建的对象和数组。堆被所有线程共享。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常
* 栈区:`Java`栈是一块线程私有的空间，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆中
    * 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）, Java虚拟机栈是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）。每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。
    * 虚拟机栈大小的调整
        * Java虚拟机规范允许虚拟机栈的大小固定不变或者动态扩展。
        * 固定情况下：如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，则抛出`StackOverflowError`异常；
        * 可以通过 `java -Xss<size>` 设置 Java 线程堆栈大小，或者在`idea`中 `help -> edit vm option`中改变大小
    * 运行时栈帧结构(每个栈帧包含5个组成部分): 局部变量表、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address）和一些附加信息 (异常处理表)
        * 局部变量表：一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
        * 操作数栈：主要保存计算过程的中间结果，同时作为计算过程中的变量临时的存储空间。
        * 帧数据区:除了局部变量表和操作数据栈以外，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便计程序访问常量池，另外当函数返回或出现异常时卖虚拟机子必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表也是帧数据区的一部分。
* 本地方法栈 :本地方法栈则是为了执行`native`方法所服务的.只是这个栈是属于本地的,不属于`JAVA`虚拟机,但受`JAVA`虚拟机的控制.调用一个`C`函数使用。
* 方法区:Java方法区和堆一样，方法区是一块所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量
    * 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。
    * 元空间不在虚拟机设置的内存中，而是使用本地内存。类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。

# JVM 参数调优
在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排查会有一定的帮助，为此，在虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行Java虚拟机，就可以在系统运行时打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实就是**围绕着堆、栈、方法区进行配置**，而最多的就是**关于堆内存中新生代和老年代的参数配置**
* 堆的参数配置
    * `-XX:+PrintGC` 每次触发GC的时候打印相关日志
    * `-XX:+PrintGCDetails` 更详细的GC日志
    * `-Xms` 堆初始值
    * `-Xmx` 堆最大可用值
    * `-Xmn` 新生代堆最大可用值
    * `-XX:SurvivorRatio` 用来设置新生代中eden空间和from/to空间的比例.
* 设置新生代与老年代优化参数
    * `-Xmn` 新生代大小，一般设为整个堆的1/3到1/4左右
    * `-XX:SurvivorRatio` 设置新生代中eden区和from/to空间的比例关系n/1
    * `-Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC`
    * `-Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC`
    * `-XX:NewRatio=2`

不同的堆分布情况，对系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。除了可以设置新生代的绝对大小(`-Xmn`),可以使用`(-XX:NewRatio`)设置新生代和老年代的比例:`-XX:NewRatio`=老年代/新生代

内存溢出解决办法:
* 设置堆内存大小
    * 错误原因: `java.lang.OutOfMemoryError`: Java heap space
    * 解决办法:设置堆内存大小 `-Xms1m -Xmx70m -XX:+HeapDumpOnOutOfMemoryError`
* 设置栈内存大小
    * 错误原因: `java.lang.StackOverflowError`. 栈溢出, 产生于递归调用，循环遍历是不会的，但是循环方法里面产生递归调用， 也会发生栈溢出。
    * 解决办法:设置线程最大调用深度, `-Xss5m` 设置最大调用深度

# 垃圾回收 GC
分为2种，一是`Minor GC`，可以可以称为`YGC`，即年轻代GC.还有一种称为`Major GC`，又称为`FullGC`

* `Minor GC`触发条件：
    * JVM 无法为一个新对象分配内存空间时 
* `Full GC`触发条件：
    * 调用`System.gc`时
    * 老年代空间不足
    * 方法区空间不足
    * 通过`Minor GC`后进入老年代的平均大小大于老年代的可用内存
        * 这是一种避免在新生代GC时发生`promotion failed`的机制。`promotion failed`是指在新生代GC时，有些对象无法放入`Survivor`区，需要晋升到老年代，但是老年代空间不足，导致GC失败。为了防止这种情况，JVM会在每次新生代GC前**检查老年代的可用空间是否大于新生代的所有对象大小**，如果不是，就会再检查老年代的可用空间**是否大于历次新生代GC后晋升到老年代的对象的平均大小**，如果还不是，就会触发Full GC，回收老年代的垃圾对象，为新生代GC后的对象晋升腾出空间。

## JVM内存分配担保原则
在JDK1.5以及之前版本中默认是关闭的，需要通过`HandlePromotionFailure`手动指定，JDK1.6之后就默认开启。

内存分配是在JVM在内存分配的时候，新生代内存不足时，`eden space`的对象（`6MB`）又无法全部放入`Survivor`空间。把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老年代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。在`Serial+Serial Old`的情况下，发现放不下就直接启动担保机制；在`Parallel Scavenge+Serial Old`的情况下，却是先要去判断一下要分配的内存是不是`>=Eden`区大小的一半，如果是那么直接把该对象放入老生代，否则才会启动担保机制。

* 要在新生代实行`Minor GC`的时候，首先要检查年老代中连续的最大的内存空间是否大于新生代中所有的对象的大小
    * 如果大于，那么进行`Minor GC`
    * 如果小于，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
        * 如果大于,将尝试者进行一次`Minor GC`,尽管这次`Minor GC`是有风险的。
        * 如果小于
            * 如果`HandlePromotionFailure`设置不允许冒险,那这时也要改为进行一次`Full GC`.
            * 否则老年代无法装下，垃圾收集器进行一次预测：根据以往`minorGC`过后存活对象的平均数来预测这次`minorGC`后存活对象的平均数。有以下两种情况：
                * 以往平均数小于当前老年代最大的连续空间，就进行`minorGC`
                * 大于，则进行一次`fullGC`，通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代做担保。

## 内存分配原则

* 对象优先在 `Eden` 分配
* 大多数情况下，对象在新生代 `Eden` 区中分配。当 `Eden` 区没有足够空间进行分配时，虚拟机将发起 `Minor GC`。
* 大对象直接进入老年代
* 长期存活的对象将进入老年代
* 虚拟机给每个对象定义了一个对象年龄（`Age`）计数器。如果对象在 `Survivor` 区中每熬过一次 `Minor GC`，年龄加 1 岁，当年龄到一定程度（默认`15`岁），就会晋升到老年代中。
* 动态对象年龄判定: 在 `Survivor` 空间中相同年龄所有对象大小的总和大于 `Survivor` 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

## 垃圾收集算法

在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。

* 标记-清除算法（Mark-Sweep）: 这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
    * 优点：实现起来比较容易
    * 缺点：有一个比较严重的问题就是容易产生**内存碎片**，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。
* 复制算法（Copying）：为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量**划分为大小相等的两块，每次只使用其中的一块。**当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题
    * 优点：实现简单，运行高效且不容易产生内存碎片
    * 缺点：对内存空间的使用做出了高昂的代价，因为**能够使用的内存缩减到原来的一半**。很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，**如果存活对象很多，那么Copying算法的效率将会大大降低**。
* 标记-整理算法（Mark-Compact）（压缩法）：为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是**在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。**
* 分代收集算法（Generational Collection）：不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。
    * 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法
    * 目前大部分垃圾收集器对于**新生代都采取复制算法**，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照`1：1`的比例来划分新生代的空间的，一般来说是**将新生代划分为一块较大的`Eden`空间和两块较小的`Survivor`空间，每次使用`Eden`空间和其中的一块`Survivor`空间**，当进行回收时，将`Eden`和`Survivor`中还存活的对象复制到另一块`Survivor`空间中，然后清理掉`Eden`和刚才使用过的`Survivor`空间。
    * 而由于**老年代**的特点是每次回收都只回收少量对象，一般使用的是**标记-整理算法（压缩法）**

分代的垃圾回收策略: 是基于这样一个事实, 不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。
* 年轻代（Young Generation）
    1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
    2. 新生代内存按照`8:1:1`的比例分为一个`eden`区和两个`survivor`(`survivor0`,`survivor1`)区。一个`Eden`区，两个 `Survivor` 区(一般而言)。大部分对象在`Eden`区中生成。回收时先将`eden`区存活对象复制到一个`survivor0`区，然后清空`eden`区，当这个`survivor0`区也存放满了时，则将`eden`区和`survivor0`区存活对象复制到另一个`survivor1`区，然后清空`eden`和这个`survivor0`区，此时`survivor0`区是空的，然后将`survivor0`区和`survivor1`区交换，即保持`survivor1`区为空， 如此往复。
    3. 当`survivor1`区不足以存放 `eden`和`survivor0`的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次`Full GC`，也就是新生代、老年代都进行回收
    4. 新生代发生的GC也叫做`Minor GC`，`MinorGC`发生频率比较高(不一定等`Eden`区满了才触发)
* 年老代（Old Generation）
    1. 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
    2. 内存比新生代也大很多(大概比例是`1:2`)，当老年代内存满时触发`Major GC`即`Full GC`，`Full GC`发生频率比较低，老年代对象存活时间比较长，存活率标记高。
* 持久代（Permanent Generation）: 用于存放静态文件，如`Java`类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些`class`，例如`Hibernate` 等，在这种时候需要**设置一个比较大的持久代空间来存放这些运行过程中新增的类**。

## 可达性分析

引用计数法（Java没有采用）: 在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。
    * 优点：实现简单，而且效率较高
    * 缺点：**无法解决循环引用的问题**，因此在 Java 中并没有采用这种方式（Python采用的是引用计数法）。


可达性分析通过一系列称为“`GC Roots`”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 `GC Roots` 没有任何的引用链相连时(从 `GC Roots` 到这个对象不可达)时，证明此对象不可用。可作为GC Roots的对象包含以下几种：
* 虚拟机栈中的引用的对象，我们在程序中正常创建一个对象
* 我们在类中定义了全局的静态的对象，也就是使用了`static`关键字
* 常量引用，就是使用了`static final`关键字


三色标记法：
* 我们把遍历对象图过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：
    * 白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。
    * 黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。
    * 灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。
* 标记过程：
    1. 在GC并发标记刚开始时，所以对象均为白色集合。
    2. 将所有GCRoots直接引用的对象标记为灰色集合。
    3. 判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合
    4. 按照步骤3，以此类推，直至灰色集合中的所有对象变成黑色后，本轮标记完成，且当前白色集合内的对象称为不可达对象，既垃圾对象。
* 问题：由于此过程是在和用户线程并发运行的情况下，对象的引用处于随时可变的情况下，那么就会造成**多标和漏标**的问题。
    * 浮动垃圾：本应该被标记为白色的对象，没有被标记，造成该对象可能不会被回收。
    * 漏标：灰色对象指向白色对象的引用消失了，然后一个黑色的对象重新引用了白色对象。
        * 不难分析，漏标只有同时满足以下两个条件时才会发生：
        * 条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。
        * 条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。
* 解决方案
    * CMS：`Incremental Update`算法：当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。（破坏条件二）
    * G1：SATB（Snapshot At The Beginning）算法：当原来成员变量的引用发生变化之前，记录下原来的引用对象，既原始快照，当B和C之间的引用马上被断掉时，将这个引用记录下来，使GC依旧能够访问到，那样白色就不会漏标。（破坏条件一）

JVM之判断对象是否存活：可达性分析 -> 第一次标记 -> 第二次标记
* 标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。
* 第一次标记并进行一次筛选：筛选的条件是此对象是否有必要执行`finalize()`方法。当对象没有覆盖`finalize`方法，或者`finzlize`方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。
* 第二次标记：如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象将会被放置在一个名为：`F-Queue`的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的`Finalizer`线程去执行。
    * `Finalize()`方法是对象脱逃死亡命运的最后一次机会，稍后GC将对`F-Queue`中的对象进行第二次小规模标记，如果对象要在`finalize()`中成功拯救自己, 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。


